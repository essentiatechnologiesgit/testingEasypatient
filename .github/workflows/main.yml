name: iOS Certificate Automation

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: macos-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: '3.x'
      
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 3.3

      - name: Install dependencies
        run: |
          gem install jwt
          pip install requests

      - name: Generate RSA Private Key and CSR
        run: |
          openssl genpkey -algorithm RSA -out rsa_private.key -pkeyopt rsa_keygen_bits:2048
          openssl req -new -key rsa_private.key -out csr.certSigningRequest -subj "/CN=suporte@easy-health.app, C=US"

      - name: Display Generated CSR Contents
        run: |
          cat csr.certSigningRequest

          
      - name: Display CSR Contents
        id: display_csr
        run: |
          csr_content=$(cat csr.certSigningRequest)
          echo "CSR Content: $csr_content"
          echo "CSR_CONTENT<<EOF" >> $GITHUB_ENV
          echo "$csr_content" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Use CSR Content
        run: |
          echo "CSR Content saved in env variable:"
          echo "$CSR_CONTENT"

      - name: Generate JWT
        id: generate_jwt
        run: |
          ISSUER_ID="ad39d400-3314-48f8-977c-29a272eebad0"
          KEY_ID="74H4QHFPVP"
          private_key="
          -----BEGIN PRIVATE KEY-----
          MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgmtzyTVPL1cphRZjf
          pzIlE/6pV5OFCS6zaUoyqBIHflygCgYIKoZIzj0DAQehRANCAASQxfZ0NyqZre50
          6NGowYahQsvqEQew5MStUc94chxoi8QqtVNTOcsgzqflnQ/v7YeETnnUX+P+2+2E
          +EG+nw8t
          -----END PRIVATE KEY-----
          "

          token=$(ruby -rjwt -ropenssl -e "
            private_key_obj = OpenSSL::PKey::EC.new('$private_key')
            token = JWT.encode(
              {
                iss: '$ISSUER_ID',
                exp: Time.now.to_i + 20 * 60,
                aud: 'appstoreconnect-v1'
              },
              private_key_obj,
              'ES256',
              header_fields = {
                kid: '$KEY_ID'
              }
            )
            puts token
          ")
          
          echo "token=$token" >> $GITHUB_ENV

#       # - name: Revoke the hardcoded certificate
#       #   run: |
#       #     import requests
#       #     import os

#       #     # Hardcoded JWT and Certificate ID
       
#       #     certificate_id = "LDXBV2688Z"

#       #     # API URL
#       #     url = f"https://api.appstoreconnect.apple.com/v1/certificates/{certificate_id}"
#       #     headers = {
#       #         "Authorization": f"Bearer {os.getenv('token')}",
#       #     }
          
#       #     # Making the DELETE request to revoke the certificate
#       #     response = requests.delete(url, headers=headers)
          
#       #     # Print the status and response content
#       #     print(f"Status Code: {response.status_code}")
#       #     if response.status_code == 204:
#       #         print("Certificate revoked successfully.")
#       #     else:
#       #         print("Failed to revoke certificate.")
#       #         print(response.text)
#       #   shell: python

      - name: Request and Save Distribution Certificate
        run: |
          python <<EOF
          import os
          import requests
          
          csr_content = os.getenv('CSR_CONTENT')
          
          url = "https://api.appstoreconnect.apple.com/v1/certificates"
          headers = {
              "Authorization": f"Bearer {os.getenv('token')}",
              "Content-Type": "application/json"
          }
          data = {
              "data": {
                "type": "certificates",
                "attributes": {
                  "certificateType": "DISTRIBUTION",
                  "csrContent": csr_content
                }
              }
          }
          
          response = requests.post(url, json=data, headers=headers)
          
          if response.status_code == 201:
              cert_data = response.json()['data']
              cert_id = cert_data['id']
              cert_serial_number = cert_data['attributes']['serialNumber']
              
              print(f"Certificate ID: {cert_id}")
              print(f"Serial Number: {cert_serial_number}")
              
              # Save the certificate content to a file
              cert_content = cert_data['attributes']['certificateContent']
              with open('distribution.cer', 'w') as cert_file:
                  cert_file.write("-----BEGIN CERTIFICATE-----\n")
                  cert_file.write(cert_content + "\n")
                  cert_file.write("-----END CERTIFICATE-----\n")
              print("Distribution Certificate created successfully")
              
              # Save Certificate ID to a file
              with open('certificate_id.txt', 'w') as id_file:
                  id_file.write(cert_id)
          else:
              print("Failed to create Distribution Certificate")
              print(response.status_code)
              print(response.json())
              exit(1)
          EOF
      
      - name: Set Certificate ID as Environment Variable
        run: echo "CERTIFICATE_ID=$(cat certificate_id.txt)" >> $GITHUB_ENV

      - name: Debug - Print Certificate Content
        run: cat distribution.cer

      - name: Convert Certificate to .p12 format
        run: |
          ISSUER_ID="ad39d400-3314-48f8-977c-29a272eebad0"
          KEY_ID="74H4QHFPVP"
          private_key="-----BEGIN PRIVATE KEY-----
          MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgmtzyTVPL1cphRZjf
          pzIlE/6pV5OFCS6zaUoyqBIHflygCgYIKoZIzj0DAQehRANCAASQxfZ0NyqZre50
          6NGowYahQsvqEQew5MStUc94chxoi8QqtVNTOcsgzqflnQ/v7YeETnnUX+P+2+2E
          +EG+nw8t
          -----END PRIVATE KEY-----"
          
          CERT_P12_PASSWORD="private_pass"
      
          echo "$private_key" > private_key.pem
      
          openssl pkcs12 -export -inkey rsa_private.key -in distribution.cer -out distribution.p12 -password pass:$CERT_P12_PASSWORD
     
      - name: Upload .p12 file as GitHub Actions artifact
        uses: actions/upload-artifact@v3
        with:
          name: distribution-certificate
          path: distribution.p12
                
      - name: Import certificate to keychain
        run: |
          # Path to the keychain
          KEYCHAIN_NAME="build.keychain"
          KEYCHAIN_PASSWORD="private_pass"
          CERT_P12_PASSWORD="private_pass"
          KEYCHAIN_PATH=~/Library/Keychains/"$KEYCHAIN_NAME"
          
          # Create a new keychain with restricted permissions
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          if [ $? -ne 0 ]; then
              echo "Error creating keychain"
              exit 1
          fi
          
          # Debug: List keychains and check for the created keychain
          echo "Listing keychains in ~/Library/Keychains/:"
          ls ~/Library/Keychains/
          
          # Correct path detection: handle .keychain and .keychain-db formats
          if [ ! -f "$KEYCHAIN_PATH" ] && [ -f "${KEYCHAIN_PATH}-db" ]; then
              KEYCHAIN_PATH="${KEYCHAIN_PATH}-db"
          fi
          
          # Verify the keychain file exists
          if [ -f "$KEYCHAIN_PATH" ]; then
              echo "Keychain file exists at: $KEYCHAIN_PATH"
          else
              echo "Keychain file does not exist at: $KEYCHAIN_PATH"
              exit 1
          fi
          
          # Set the keychain as the default keychain
          security default-keychain -s "$KEYCHAIN_PATH"
          echo "Default keychain set to: $KEYCHAIN_PATH"
          
          # Unlock the keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          echo "Attempted to unlock keychain: $KEYCHAIN_PATH"
          
          # Check if the keychain is unlocked
          UNLOCK_STATUS=$(security show-keychain-info "$KEYCHAIN_PATH" 2>&1 || echo "Keychain is locked")
          echo "Keychain status: $UNLOCK_STATUS"
          
          # Set the keychain timeout to a reasonable value (e.g., 3600 seconds)
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_PATH"
          echo "Keychain timeout set to 3600 seconds"
          
          # Set key partition list for the keychain
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          if [ $? -ne 0 ]; then
              echo "Error setting key partition list"
              exit 1
          fi
          echo "Key partition list set for keychain: $KEYCHAIN_PATH"
          
          # Debug: Verify the existence of the .p12 file and provisioning profile
          if [ ! -f "distribution.p12" ]; then
              echo "Error: distribution.p12 file not found"
              exit 1
          fi
          if [ ! -f "provisioning_profile.mobileprovision" ]; then
              echo "Error: provisioning_profile.mobileprovision file not found"
              exit 1
          fi
          
          # Import the .p12 file into the keychain
          security import distribution.p12 -k "$KEYCHAIN_PATH" -P "$CERT_P12_PASSWORD" -T /usr/bin/codesign
          if [ $? -ne 0 ]; then
              echo "Error importing certificate"
              exit 1
          fi
          echo "Certificate import attempt completed."
          
          # Import the provisioning profile into the keychain
          security import provisioning_profile.mobileprovision -k "$KEYCHAIN_PATH"
          if [ $? -ne 0 ]; then
              echo "Error importing provisioning profile"
              exit 1
          fi
          echo "Provisioning profile import attempt completed."
          
          # Validate that the certificate is present in the keychain
          CERT_NAME="Apple Distribution: KLQ SOLUCOES TECNOLOGICAS LTDA"
          CERTIFICATE=$(security find-certificate -a -c "$CERT_NAME" -p "$KEYCHAIN_PATH" 2>&1)
          if [[ "$CERTIFICATE" == *"could not be found"* ]]; then
              echo "Error: Certificate not found in keychain"
              exit 1
          fi
          echo "Certificate found and validated in keychain"
          
          # Print the keychain contents for debugging (optional)
          security list-keychains
          security find-certificate -a -p




#       # - name: Retrieve All App IDs
#       #   run: |
#       #     echo "Retrieving App IDs..."
#       #     response=$(curl -s -X GET https://api.appstoreconnect.apple.com/v1/bundleIds \
#       #       -H "Authorization: Bearer ${{ env.token }}" \
#       #       -H "Content-Type: application/json")
          
#       #     echo "$response" > bundle_ids.json
#       #     echo "Bundle IDs Response: $response"

#       #     # # Extract and print App IDs
#       #     # bundle_ids=$(jq -r '.data[].id' bundle_ids.json)
#       #     # echo "App IDs: $bundle_ids"
#       #     # echo "bundle_ids=$bundle_ids" >> $GITHUB_ENV

      - name: Create Distribution Provisioning Profile
        run: |
          echo "Creating Distribution Provisioning Profile..."
          
          PROFILE_NAME="MyApp Distribution Profile 9"  
          # BUNDLE_ID="${{ env.bundle_id }}"  
          BUNDLE_ID="7Y7S27X27N"
          CERTIFICATE_ID="${{ env.CERTIFICATE_ID }}"  
           # CERTIFICATE_ID="5QW8CZ7GNM"
          
          response=$(curl -X POST https://api.appstoreconnect.apple.com/v1/profiles \
            -H "Authorization: Bearer ${{ env.token }}" \
            -H "Content-Type: application/json" \
            -d @- <<EOF
          {
            "data": {
              "type": "profiles",
              "attributes": {
                "name": "$PROFILE_NAME",
                "profileType": "IOS_APP_STORE"
              },
              "relationships": {
                "bundleId": {
                  "data": {
                    "type": "bundleIds",
                    "id": "$BUNDLE_ID"
                  }
                },
                "certificates": {
                  "data": [
                    {
                      "type": "certificates",
                      "id": "$CERTIFICATE_ID"
                    }
                  ]
                }
              }
            }
          }
          EOF
          )
      
          echo "Profile Response: $response"
          
          # Save the profile ID or the profile content if needed
          echo "Profile Response: $response"
          
          # Extract the Base64 encoded profile content
          profile_content=$(echo "$response" | jq -r '.data.attributes.profileContent')
          
          # Log the profile content length
          echo "Profile content length: $(echo "$profile_content" | wc -c)"
          
          # Ensure the directory exists before saving the profile
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          
          # Decode the Base64 content and save it as a .mobileprovision file
          echo "$profile_content" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/MyApp_Distribution_Profile_9.mobileprovision
  

      - name: Install CocoaPods
        run: gem install cocoapods

      - name: Cache CocoaPods
        uses: actions/cache@v3
        with:
          path: ios/Pods
          key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pods-

      - name: Install Node.js dependencies
        run: npm install --force

      - name: Install Pods
        run: |
          cd ios
          pod deintegrate
          rm -rf Pods Podfile.lock
          pod update
          pod install

      - name: Install Xcode 15.3
        run: |
          sudo xcode-select -s /Applications/Xcode_15.3.app/Contents/Developer
          xcodebuild -version


      - name: Clean Derived Data
        run: rm -rf ~/Library/Developer/Xcode/DerivedData/*

     
      - name: Clean Build Folder
        run: |
          cd ios
          xcodebuild clean -workspace testing.xcworkspace -scheme testing -configuration Release

      - name: Build Archive
        run: |
          xcodebuild clean archive \
            -workspace ios/testing.xcworkspace \
            -scheme testing \
            -sdk iphoneos \
            -destination generic/platform=iOS \
            -configuration Release \
            -derivedDataPath ios/build/DerivedData \
            -archivePath ios/build/archive/TestingArchive.xcarchive \
            PROVISIONING_PROFILE_SPECIFIER="MyApp Distribution Profile 9" \
            CODE_SIGN_IDENTITY="Apple Distribution: KLQ SOLUCOES TECNOLOGICAS LTDA" \
            DEVELOPMENT_TEAM="XGK8AJH7WW"
      
    
      

#       - name: Update App Metadata
#         run: |
#           python <<EOF
#           import os
#           import requests
          
#       #     app_id = "36FLSCQT6V"  # The ID of the app you want to update
#       #     token = os.getenv('token')  # Your JWT token for authorization
      
#       #     # Define the metadata you want to update
#       #     metadata = {
#       #         "data": {
#       #             "type": "apps",
#       #             "id": app_id,
#       #             "attributes": {
#       #                 "name": "Health App",
#       #                 "subtitle": "New Subtitle",
#       #                 "description": "Updated app description.",
#       #                 "keywords": "keyword1, keyword2",
#       #                 "supportUrl": "https://support.example.com",
#       #                 "marketingUrl": "https://marketing.example.com",
#       #                 "privacyPolicyUrl": "https://privacy.example.com",
#       #                 "primaryCategory": "6021",  # Example category ID for "Business"
#       #                 "secondaryCategory": "6011",  # Example category ID for "Productivity"
#       #                 "ageRating": "12+"  
#       #             }
#       #         }
#       #     }
      
#       #     url = f"https://api.appstoreconnect.apple.com/v1/apps/{app_id}"
#       #     headers = {
#       #         "Authorization": f"Bearer {token}",
#       #         "Content-Type": "application/json"
#       #     }
      
#       #     response = requests.patch(url, json=metadata, headers=headers)
      
#       #     if response.status_code == 200:
#       #         print("App metadata updated successfully")
#       #     else:
#       #         print("Failed to update app metadata")
#       #         print(response.status_code)
#       #         print(response.json())
#       #         exit(1)
#       #     EOF
